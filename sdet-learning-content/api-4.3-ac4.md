# API Key Authentication in API Testing

## Overview
API Key authentication is a simple and widely used method to secure access to APIs. It involves generating a unique alphanumeric string (the API Key) and sending it with each request to identify the client and grant access. This feature explores how to implement and test API Key authentication, focusing on common patterns where the key is sent either in the request header or as a query parameter. Understanding API Key mechanics is crucial for SDETs as it's a fundamental aspect of securing and interacting with many web services.

## Detailed Explanation
API Keys are typically generated by the API provider and assigned to a specific user or application. When a client makes a request, this key acts as a token to verify the client's identity.

There are two primary ways an API Key is commonly transmitted:

1.  **In the Request Header:** This is often preferred for security reasons. The API Key is sent within a custom header (e.g., `X-API-Key`, `Authorization`, or a custom name specified by the API documentation).
2.  **As a Query Parameter:** The API Key is appended to the URL as part of the query string (e.g., `?apiKey=YOUR_API_KEY`). While simpler to implement, it's generally less secure than headers because URLs can be logged, stored in browser history, or exposed in server logs.

Regardless of the transmission method, the API server receives the key, validates it against its stored keys, and if valid, grants access based on the permissions associated with that key.

### Identifying API Key Location (Header vs. Query Param)
To determine where to send the API Key, always refer to the API documentation. The documentation will explicitly state the parameter name (e.g., `apiKey`, `key`), its expected value format, and whether it should be in a header or query parameter.

## Code Implementation
Here are examples using Rest Assured in Java for both header and query parameter API Key authentication.

```java
import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.testng.Assert;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.equalTo;

public class ApiKeyAuthenticationTest {

    // --- Configuration for API Key ---
    // IMPORTANT: Replace with your actual API endpoint and API Key.
    // For demonstration, we'll use a mock API or a public API that uses API keys.
    // Example: The OpenWeatherMap API uses API keys, often as a query parameter.
    // For header-based, imagine a service like GitHub (though it uses OAuth/PATs more commonly).

    private static final String BASE_URL = "https://api.example.com"; // Replace with actual API base URL
    private static final String API_KEY_HEADER_NAME = "X-API-Key"; // Common header name
    private static final String API_KEY_QUERY_PARAM_NAME = "apiKey"; // Common query parameter name
    private static final String VALID_API_KEY = "your_valid_api_key_here"; // Replace with your actual valid API key
    private static final String INVALID_API_KEY = "invalid_api_key";
    private static final String SECURE_ENDPOINT = "/secured/data"; // An endpoint requiring authentication
    private static final String PUBLIC_ENDPOINT = "/public/info"; // An endpoint not requiring authentication

    @BeforeClass
    public void setup() {
        RestAssured.baseURI = BASE_URL;
    }

    // --- Scenario 1: API Key in Header ---

    @Test(description = "Verify access with a valid API Key in header")
    public void testApiKeyInHeader_ValidKey() {
        given()
            .header(API_KEY_HEADER_NAME, VALID_API_KEY) // Pass the API Key in the header
        .when()
            .get(SECURE_ENDPOINT)
        .then()
            .statusCode(200) // Expect 200 OK for successful authentication and access
            .body("message", equalTo("Access granted for user")); // Example assertion
    }

    @Test(description = "Verify access denied with a missing API Key in header")
    public void testApiKeyInHeader_MissingKey() {
        given()
        // No API Key header is sent
        .when()
            .get(SECURE_ENDPOINT)
        .then()
            .statusCode(401) // Expect 401 Unauthorized or 403 Forbidden
            .body("error", equalTo("Unauthorized: API Key missing")); // Example assertion
    }

    @Test(description = "Verify access denied with an invalid API Key in header")
    public void testApiKeyInHeader_InvalidKey() {
        given()
            .header(API_KEY_HEADER_NAME, INVALID_API_KEY) // Pass an invalid API Key
        .when()
            .get(SECURE_ENDPOINT)
        .then()
            .statusCode(401) // Expect 401 Unauthorized or 403 Forbidden
            .body("error", equalTo("Unauthorized: Invalid API Key")); // Example assertion
    }

    // --- Scenario 2: API Key as Query Parameter ---

    // Example using a real public API: OpenWeatherMap (replace with your actual API key)
    // Note: OpenWeatherMap usually requires a city name as well. This is a simplified example.
    private static final String OPENWEATHER_BASE_URL = "https://api.openweathermap.org/data/2.5";
    private static final String OPENWEATHER_CURRENT_WEATHER_ENDPOINT = "/weather";
    private static final String OPENWEATHER_VALID_API_KEY = "YOUR_OPENWEATHER_API_KEY"; // Get from openweathermap.org

    @Test(description = "Verify access with a valid API Key as query parameter (OpenWeatherMap example)")
    public void testApiKeyAsQueryParam_ValidKey() {
        // Temporarily change base URI for this specific test if needed
        RestAssured.baseURI = OPENWEATHER_BASE_URL;

        given()
            .queryParam("q", "London") // Additional required query param for OpenWeatherMap
            .queryParam(API_KEY_QUERY_PARAM_NAME, OPENWEATHER_VALID_API_KEY) // Pass API Key as query parameter
        .when()
            .get(OPENWEATHER_CURRENT_WEATHER_ENDPOINT)
        .then()
            .statusCode(200)
            .body("name", equalTo("London")); // Assert on a specific part of the response
        
        // Reset base URI if necessary
        RestAssured.baseURI = BASE_URL;
    }

    @Test(description = "Verify access denied with a missing API Key as query parameter")
    public void testApiKeyAsQueryParam_MissingKey() {
        // Use the original BASE_URL and SECURE_ENDPOINT for this general test case
        given()
            .queryParam("param1", "value1") // Other legitimate query params, but no API Key
        .when()
            .get(SECURE_ENDPOINT)
        .then()
            .statusCode(401) // Expect 401 Unauthorized or 403 Forbidden
            .body("error", equalTo("Unauthorized: API Key missing"));
    }

    @Test(description = "Verify access denied with an invalid API Key as query parameter")
    public void testApiKeyAsQueryParam_InvalidKey() {
        // Use the original BASE_URL and SECURE_ENDPOINT for this general test case
        given()
            .queryParam(API_KEY_QUERY_PARAM_NAME, INVALID_API_KEY) // Pass an invalid API Key
        .when()
            .get(SECURE_ENDPOINT)
        .then()
            .statusCode(401) // Expect 401 Unauthorized or 403 Forbidden
            .body("error", equalTo("Unauthorized: Invalid API Key"));
    }

    // --- Verification of public endpoints (no API key needed) ---

    @Test(description = "Verify access to public endpoint without API Key")
    public void testPublicEndpoint_NoAuthRequired() {
        given()
        .when()
            .get(PUBLIC_ENDPOINT)
        .then()
            .statusCode(200)
            .body("status", equalTo("public access ok")); // Example assertion for public endpoint
    }
}
```

## Best Practices
-   **Treat API Keys as Sensitive Information:** Never hardcode API Keys directly into your source code. Use environment variables, configuration files (e.g., `application.properties`, `.env`), or secure secrets management systems (e.g., HashiCorp Vault, AWS Secrets Manager).
-   **Use Headers Over Query Parameters:** When possible, transmit API Keys in request headers (`X-API-Key`, `Authorization`) rather than as query parameters to reduce exposure in logs, browser history, and referer headers.
-   **Least Privilege Principle:** Generate API Keys with the minimum necessary permissions. If a key only needs read access to a specific resource, it should not have write or delete permissions.
-   **Regular Rotation:** Periodically rotate API Keys to minimize the window of exposure if a key is compromised.
-   **Rate Limiting:** Implement rate limiting on the server side to prevent abuse, even with valid API Keys.
-   **IP Whitelisting:** If your API allows it, restrict API Key usage to specific IP addresses to add an extra layer of security.
-   **Error Handling:** Ensure your API provides clear, but not overly descriptive, error messages for authentication failures (e.g., "Unauthorized", "Invalid API Key") without revealing too much information to potential attackers.

## Common Pitfalls
-   **Hardcoding API Keys:** Leads to security vulnerabilities if the code is committed to a public repository or shared inadvertently.
-   **Logging API Keys:** Accidentally logging requests that contain API Keys (especially in query parameters) can expose them in server logs. Configure logging carefully.
-   **Reusing API Keys:** Using a single API Key for multiple applications or environments increases the blast radius if that key is compromised.
-   **Not Validating on Server-Side:** Relying solely on client-side security for API Keys is a critical server-side vulnerability. Always validate keys on the backend.
-   **Using Weak API Key Generation:** Generating predictable or easily guessable API Keys makes them susceptible to brute-force attacks. Use strong, random, and sufficiently long keys.

## Interview Questions & Answers
1.  **Q: What is API Key authentication and when would you use it?**
    **A:** API Key authentication is a simple token-based mechanism where a unique key is sent with each API request to identify the client. It's suitable for situations requiring basic client identification and access control, often for public APIs, machine-to-machine communication, or when a full OAuth flow is overkill. It's less secure than OAuth for user authentication but provides a straightforward way to manage access for applications.

2.  **Q: What are the security considerations when using API Keys?**
    **A:** API Keys should be treated like passwords. Key considerations include: not hardcoding them, storing them securely (e.g., environment variables, secrets management), transmitting them via headers (not query parameters) to prevent logging exposure, rotating them regularly, and applying the principle of least privilege. Rate limiting and IP whitelisting can further enhance security.

3.  **Q: How do you handle a compromised API Key?**
    **A:** If an API Key is suspected to be compromised, the first step is to immediately revoke it on the API provider's side. Then, investigate the source of the compromise, update any affected systems with a new, securely managed key, and review security practices to prevent future incidents.

4.  **Q: Differentiate between sending an API Key in a header versus a query parameter.**
    **A:** When sent in a header (e.g., `X-API-Key`), the key is part of the HTTP request headers and is generally more secure as it's less likely to be logged by intermediaries or appear in URLs. When sent as a query parameter (e.g., `?apiKey=abc`), it's appended to the URL. This is less secure because URLs are often logged, can appear in browser history, and might be exposed in referrer headers. Headers are the preferred method for sensitive data like API Keys.

## Hands-on Exercise
1.  **Obtain an API Key:** Sign up for a free OpenWeatherMap API key (or similar public API that uses keys).
2.  **Modify the Example Code:**
    *   Update `OPENWEATHER_VALID_API_KEY` in the provided Java code with your actual OpenWeatherMap API key.
    *   Modify the `testApiKeyAsQueryParam_ValidKey` method to fetch weather data for your favorite city.
3.  **Create a Mock API (Optional but Recommended):** Use a tool like Postman Mock Servers, Mockoon, or WireMock to set up a simple mock API that expects an API Key in a header (e.g., `X-API-Key`).
    *   Configure one endpoint to return 200 OK with a valid key.
    *   Configure another endpoint to return 401 Unauthorized without a key or with an invalid key.
4.  **Write Tests for Mock API:** Extend the `ApiKeyAuthenticationTest` class to include tests that interact with your mock API, verifying both successful authentication and authentication failures for header-based API Keys.

## Additional Resources
-   **OWASP API Security Top 10:** [https://owasp.org/www-project-api-security/](https://owasp.org/www-project-api-security/) (Provides broader API security context, including authentication)
-   **Rest Assured Documentation:** [https://rest-assured.io/](https://rest-assured.io/) (Official documentation for the Java HTTP client used in examples)
-   **OpenWeatherMap API:** [https://openweathermap.org/api](https://openweathermap.org/api) (A public API you can use for hands-on practice with API keys)
-   **Baeldung Tutorial on Rest Assured Authentication:** [https://www.baeldung.com/rest-assured-authentication](https://www.baeldung.com/rest-assured-authentication) (Covers various authentication methods with Rest Assured)
