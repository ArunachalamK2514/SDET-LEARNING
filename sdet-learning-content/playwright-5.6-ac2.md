# Playwright API Testing: Performing CRUD Requests

## Overview
Playwright's `APIRequest` context is a powerful tool for testing backend APIs directly within your E2E test framework or for dedicated API testing. It allows you to send HTTP requests (GET, POST, PUT, DELETE) and assert on the responses, status codes, and headers, providing a robust way to ensure your API behaves as expected, independent of the UI. This capability is crucial for SDETs as it enables faster feedback cycles, more stable tests, and comprehensive coverage of application logic residing in the backend.

## Detailed Explanation
Playwright provides the `request` fixture, which is an instance of `APIRequestContext`. This fixture can be used in your tests to make various HTTP calls. It automatically handles things like base URLs, authentication, and headers if configured globally in `playwright.config.ts`.

### Key Concepts:
- **`request.get(url, options)`**: Sends a GET request to retrieve data.
- **`request.post(url, options)`**: Sends a POST request to create new data, typically sending a request body.
- **`request.put(url, options)`**: Sends a PUT request to update existing data, also typically sending a request body.
- **`request.delete(url, options)`**: Sends a DELETE request to remove data.
- **`APIResponse` object**: The returned object from each request, containing methods to access status, headers, and body.
  - `response.ok()`: Returns `true` if the status code is 2xx.
  - `response.status()`: Returns the HTTP status code.
  - `response.statusText()`: Returns the HTTP status text.
  - `response.json()`: Parses the response body as JSON.
  - `response.text()`: Returns the response body as plain text.
  - `response.headers()`: Returns an object with all response headers.

### Configuration (`playwright.config.ts`)
It's common practice to configure `baseURL` and `extraHTTPHeaders` for API requests globally. This simplifies your tests by avoiding repetitive URL and header definitions.

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  // ... other configurations ...
  use: {
    // Base URL to use in actions like `await page.goto('/')`.
    baseURL: 'https://api.example.com', // Replace with your actual API base URL
    
    // API request context options
    // All requests will be sent with this context.
    // Recommended for API testing.
    apiRequestContext: {
      baseURL: 'https://api.example.com', // Replace with your actual API base URL
      extraHTTPHeaders: {
        'Accept': 'application/json',
        // 'Authorization': `Bearer ${process.env.API_TOKEN}`, // Example for authentication
      },
      // You can also add `ignoreHTTPSErrors: true` for development environments
      // or `timeout: 10000` for API request timeouts.
    },
  },
  projects: [
    {
      name: 'api',
      testMatch: /.*\.api\.spec\.ts/, // API tests typically have a distinct naming convention
      use: {
        ...devices['Desktop Chrome'],
        // You can override or add specific API context options for this project
      },
    },
    // ... other projects for UI tests ...
  ],
});
```

## Code Implementation

Let's assume we are testing a simple "posts" API that allows creating, reading, updating, and deleting posts.

```typescript
// tests/api/posts.api.spec.ts
import { test, expect, APIRequestContext } from '@playwright/test';

// Define a type for our Post object for better type safety
interface Post {
  id?: number; // ID is usually generated by the server
  title: string;
  body: string;
  userId: number;
}

test.describe('Posts API CRUD Operations', () => {
  const BASE_API_URL = 'https://jsonplaceholder.typicode.com'; // A public fake API for demonstration
  let apiContext: APIRequestContext;
  let createdPostId: number; // To store the ID of a post created for subsequent tests

  // Set up API context before all tests in this describe block
  test.beforeAll(async ({ playwright }) => {
    // Create an API request context.
    // Note: If configured globally in playwright.config.ts, you can just use the `request` fixture.
    // This explicit creation is useful for overriding global config or for dedicated API tests
    // where you want more control.
    apiContext = await playwright.request.newContext({
      baseURL: BASE_API_URL,
      extraHTTPHeaders: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
      },
    });
  });

  // Dispose of the API context after all tests in this describe block
  test.afterAll(async () => {
    await apiContext.dispose();
  });

  test('should create a new post via POST request', async () => {
    const newPost: Post = {
      title: 'Playwright API Test Post',
      body: 'This is a test post created using Playwright API.',
      userId: 1,
    };

    const response = await apiContext.post('/posts', { data: newPost });

    // Verify status code
    expect(response.status()).toBe(201); // 201 Created for successful POST

    // Verify response body
    const responseBody: Post = await response.json();
    expect(responseBody).toMatchObject(newPost); // Check if the created post matches our input
    expect(responseBody.id).toBeDefined(); // Ensure an ID was assigned by the server

    createdPostId = responseBody.id!; // Store the ID for later tests
    console.log(`Created Post ID: ${createdPostId}`);
  });

  test('should retrieve a specific post via GET request', async () => {
    test.skip(!createdPostId, 'Skipping GET test as POST failed to create a post.');

    const response = await apiContext.get(`/posts/${createdPostId}`);

    // Verify status code
    expect(response.status()).toBe(200); // 200 OK for successful GET

    // Verify response body
    const post: Post = await response.json();
    expect(post.id).toBe(createdPostId);
    expect(post.title).toBe('Playwright API Test Post');
    console.log(`Retrieved Post: ${JSON.stringify(post)}`);
  });

  test('should update an existing post via PUT request', async () => {
    test.skip(!createdPostId, 'Skipping PUT test as POST failed to create a post.');

    const updatedTitle = 'Playwright API Test Post - Updated';
    const updatedPost: Post = {
      id: createdPostId, // Include ID for PUT request
      title: updatedTitle,
      body: 'This post has been updated by Playwright API.',
      userId: 1,
    };

    const response = await apiContext.put(`/posts/${createdPostId}`, { data: updatedPost });

    // Verify status code
    expect(response.status()).toBe(200); // 200 OK for successful PUT

    // Verify response body
    const responseBody: Post = await response.json();
    expect(responseBody.id).toBe(createdPostId);
    expect(responseBody.title).toBe(updatedTitle);
    console.log(`Updated Post: ${JSON.stringify(responseBody)}`);
  });

  test('should delete a specific post via DELETE request', async () => {
    test.skip(!createdPostId, 'Skipping DELETE test as POST failed to create a post.');

    const response = await apiContext.delete(`/posts/${createdPostId}`);

    // Verify status code
    expect(response.status()).toBe(200); // 200 OK for successful DELETE (jsonplaceholder always returns 200 for DELETE)

    // Verify that the post is actually deleted (optional, depends on API behavior)
    // For jsonplaceholder, a GET after DELETE might still return the item but it's not truly deleted.
    // In a real API, you'd expect a 404 or empty response.
    const getResponseAfterDelete = await apiContext.get(`/posts/${createdPostId}`);
    expect(getResponseAfterDelete.status()).toBe(200); // jsonplaceholder returns 200 even after delete, but with empty object.
    expect(await getResponseAfterDelete.json()).toEqual({}); // Verifies empty object for jsonplaceholder

    console.log(`Deleted Post ID: ${createdPostId}`);
  });

  test('should handle a non-existent post for GET request', async () => {
    const nonExistentId = 999999;
    const response = await apiContext.get(`/posts/${nonExistentId}`);
    expect(response.status()).toBe(404); // Not Found
    expect(response.statusText()).toBe('Not Found');
  });

  test('should retrieve all posts via GET request', async () => {
    const response = await apiContext.get('/posts');
    expect(response.status()).toBe(200);
    const posts: Post[] = await response.json();
    expect(posts.length).toBeGreaterThan(0);
    expect(posts[0].userId).toBeDefined();
    expect(posts[0].title).toBeDefined();
  });
});
```

## Best Practices
- **Centralize API Configuration**: Define `baseURL`, `extraHTTPHeaders` (like `Authorization`, `Content-Type`), and potentially `timeout` in `playwright.config.ts` under `apiRequestContext` to keep your tests DRY (Don't Repeat Yourself).
- **Use `test.beforeAll` and `test.afterAll`**: For setting up and tearing down `APIRequestContext` or any prerequisite data (e.g., creating a user before all API tests). Remember to `await apiContext.dispose()` in `afterAll`.
- **Data Driven Testing**: Use data factories or test data generators to create dynamic test data, especially for POST and PUT requests, to avoid hardcoding values.
- **Assertions on Status Codes and Body**: Always assert on the HTTP status code (`expect(response.status()).toBe(200)`) and the response body content (`expect(await response.json()).toEqual(...)`).
- **Schema Validation**: For robust API testing, consider adding schema validation (e.g., using a library like `json-schema-validator`) to ensure the response body conforms to expected data structures.
- **Error Handling**: Test negative scenarios, such as invalid input, unauthorized access, or requests to non-existent endpoints, and assert on the expected error responses and status codes (e.g., 400 Bad Request, 401 Unauthorized, 404 Not Found).
- **Idempotency**: Ensure that PUT and DELETE operations can be called multiple times without side effects beyond the initial change, if your API design supports it.
- **Environment Variables**: Use environment variables for sensitive information like API keys or different base URLs for various environments (dev, staging, production).

## Common Pitfalls
- **Hardcoding URLs**: Directly embedding full URLs in every test makes tests brittle and difficult to maintain when environments changes. Use `baseURL` in configuration.
- **Ignoring Response Verification**: Just checking if a request succeeded (`response.ok()`) isn't enough. You must verify the actual data returned and the precise status code for specific scenarios.
- **Not Disposing of `APIRequestContext`**: For explicitly created contexts, failing to call `apiContext.dispose()` can lead to resource leaks.
- **Over-reliance on Global State**: While `apiRequestContext` is great for defaults, be mindful of tests unintentionally affecting each other if they modify shared resources without proper cleanup.
- **Authentication Issues**: Incorrect or expired tokens, or missing authentication headers, are common causes of API test failures. Ensure your authentication mechanism is correctly integrated and refreshed if needed.
- **Asynchronous Operations**: Forgetting `await` before API calls or `response.json()` can lead to race conditions or incorrect assertions on pending promises.

## Interview Questions & Answers
1.  **Q: How do you perform API testing using Playwright?**
    **A:** Playwright provides the `request` fixture, which is an instance of `APIRequestContext`. We can use methods like `request.get()`, `request.post()`, `request.put()`, and `request.delete()` to send HTTP requests. It's best practice to configure a `baseURL` and common headers in `playwright.config.ts` under `apiRequestContext` to centralize settings. After sending a request, I assert on the `response.status()` and `response.json()` (or `response.text()`) to verify the API's behavior.

2.  **Q: What are the advantages of using Playwright for API testing alongside UI testing?**
    **A:** The main advantage is having a unified testing framework. It allows for seamless integration of UI and API tests in the same codebase and CI/CD pipeline, reducing context switching and setup overhead. We can use API calls to set up test data quickly for UI tests (e.g., create a user via API before testing login via UI) or to clean up data after UI tests, making UI tests faster and more reliable. It also allows for end-to-end testing scenarios that involve both UI interactions and direct API validations.

3.  **Q: How do you handle authentication in Playwright API tests?**
    **A:** Authentication tokens (e.g., Bearer tokens, API keys) can be passed in `extraHTTPHeaders` within the `apiRequestContext` configuration in `playwright.config.ts`. For dynamic tokens, I might fetch the token in a `test.beforeAll` hook using a login API call, store it in a variable, and then use it to set the `Authorization` header for subsequent API requests. Environment variables should be used to store sensitive credentials.

4.  **Q: Describe a scenario where you would use an API call to set up test data for a UI test.**
    **A:** Imagine testing an e-commerce checkout flow. Instead of navigating through the UI to add multiple items to a cart, which can be slow and flaky, I would use Playwright's `APIRequestContext` to make direct API calls to add items to the user's cart before launching the browser and starting the UI checkout process. This significantly speeds up the test execution and makes the UI test more focused on the checkout UI itself, rather than the preceding steps.

## Hands-on Exercise
**Objective**: Test a public API that allows creating and managing tasks.
**API Endpoint**: You can use a mock API service like `https://gorest.co.in/public/v2/users` and then simulate a task management system on top of it, or use a tool like [JSONPlaceholder](https://jsonplaceholder.typicode.com/) for generic data. For this exercise, let's stick with JSONPlaceholder for simplicity.

**Tasks:**
1.  **Setup**: Create a new test file `tests/api/todos.api.spec.ts`.
2.  **Create (POST)**: Write a test to create a new "todo" item. Assert that the status code is 201 and the response body contains the new todo's data, including an ID.
3.  **Read (GET)**: Write a test to retrieve a specific todo item by its ID (use the ID from the previous POST test). Assert status 200 and verify the content.
4.  **Update (PUT)**: Write a test to update the title or completion status of the todo item using its ID. Assert status 200 and verify the updated data.
5.  **Delete (DELETE)**: Write a test to delete the todo item. Assert status 200. Optionally, attempt a GET request for the deleted ID to verify it's no longer accessible (expecting 404 or an empty response depending on the API).
6.  **Negative Test**: Write a test to attempt to retrieve a non-existent todo item and assert a 404 status code.

## Additional Resources
- **Playwright API Testing Documentation**: [https://playwright.dev/docs/api-testing](https://playwright.dev/docs/api-testing)
- **Playwright `APIRequestContext`**: [https://playwright.dev/docs/class-apirequestcontext](https://playwright.dev/docs/class-apirequestcontext)
- **Playwright `APIResponse`**: [https://playwright.dev/docs/class-apiresponse](https://playwright.dev/docs/class-apiresponse)
- **JSONPlaceholder (Fake API for Testing)**: [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
