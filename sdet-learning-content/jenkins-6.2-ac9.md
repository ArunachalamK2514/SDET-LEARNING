# Archive Test Artifacts (Screenshots, Logs, Videos) in Jenkins

## Overview
In continuous integration and continuous delivery (CI/CD) pipelines, especially for automated testing, it's crucial to retain artifacts generated during test execution. These artifacts, such as screenshots, test logs, and video recordings of test runs, are invaluable for debugging failed tests, auditing test results, and providing evidence of application behavior. Jenkins provides the `archiveArtifacts` step to easily save these files directly within the build record, making them accessible from the Jenkins UI.

Archiving artifacts ensures that even if the build agent is ephemeral or the workspace is cleaned, you can still access critical diagnostic information for every build. This capability significantly streamlines the debugging process and improves the overall reliability and traceability of your test automation efforts.

## Detailed Explanation
The `archiveArtifacts` step in a Jenkins Pipeline is a post-build action that allows you to specify files or directories to be stored with the build record. These archived artifacts can then be browsed and downloaded directly from the Jenkins build page. This is particularly useful for test automation, where various diagnostic files are produced.

### How `archiveArtifacts` Works:
1.  **Pattern Matching**: You define patterns (similar to Ant-style globs) to specify which files to archive. These patterns are relative to the workspace root.
2.  **Storage**: Jenkins copies the matched files from the build agent's workspace to the Jenkins controller's storage (or a configured artifact repository) for that specific build.
3.  **Access**: Once archived, these files become part of the build's history and can be accessed via the Jenkins UI (e.g., under the "Artifacts" link on a build's summary page) or through the Jenkins API.

### Common Use Cases in SDET:
*   **Screenshots**: Capturing screenshots on test failure is a standard practice for UI test automation (e.g., Selenium, Playwright).
*   **Test Execution Logs**: Detailed logs generated by testing frameworks (e.g., TestNG, JUnit) or application logs from the system under test.
*   **Video Recordings**: For critical UI tests, recording a video of the test execution can provide comprehensive context for failures.
*   **HTML Reports**: Generating and archiving readable HTML test reports (e.g., ExtentReports, Allure Reports) for easy review.
*   **Configuration Files**: Archiving the configuration used for a specific test run for reproducibility.

## Code Implementation
Hereâ€™s an example of how to use `archiveArtifacts` in a declarative Jenkins Pipeline. This example assumes a Playwright test setup that generates screenshots on failure, a custom log file, and an HTML report.

```groovy
// Jenkinsfile
pipeline {
    agent any

    stages {
        stage('Checkout') {
            steps {
                git 'https://github.com/your-org/your-playwright-tests.git' // Replace with your repository
            }
        }
        stage('Build & Test') {
            steps {
                script {
                    // Assuming Node.js environment for Playwright tests
                    // npm install
                    // Generate a custom log file for the test run
                    sh 'echo "Starting Playwright tests..." > test-run.log'
                    sh 'npm install'
                    // Run Playwright tests. Configure Playwright to output screenshots to 'test-results/screenshots'
                    // and a detailed HTML report to 'playwright-report'.
                    // Redirect Playwright's console output to our custom log file.
                    sh 'npx playwright test --reporter=html >> test-run.log 2>&1 || true' // '|| true' to continue pipeline on test failures
                    sh 'echo "Playwright tests finished." >> test-run.log'
                }
            }
        }
    }

    post {
        always {
            script {
                // Archive various artifacts
                echo 'Archiving test artifacts...'
                archiveArtifacts artifacts: 'test-results/screenshots/*.png, test-run.log, playwright-report/**/*',
                                   fingerprint: true,
                                   allowEmpty: true // Allow archiving even if some patterns don't match anything
                echo 'Artifacts archived.'
            }
        }
        failure {
            echo 'Build failed. Review archived artifacts for details.'
        }
        success {
            echo 'Build succeeded. Artifacts are available for review.'
        }
    }
}
```

**Explanation of `archiveArtifacts` parameters:**
*   `artifacts`: A comma-separated list of Ant-style file patterns to archive.
    *   `test-results/screenshots/*.png`: Archives all PNG files found in the `test-results/screenshots` directory.
    *   `test-run.log`: Archives the custom log file generated during the test run.
    *   `playwright-report/**/*`: Archives the entire `playwright-report` directory and its contents (e.g., HTML reports).
*   `fingerprint`: (Optional, `true`/`false`) If `true`, Jenkins will "fingerprint" the archived files. This allows tracking where a specific version of an artifact was produced and used across different builds or even different jobs. Useful for traceability.
*   `allowEmpty`: (Optional, `true`/`false`) If `true`, the step will not fail the build if no files match the specified patterns. This is often desired for artifacts like screenshots, which are only generated on failure.

## Best Practices
-   **Granular Archiving**: Archive only necessary files to avoid excessive storage consumption and reduce build processing time.
-   **Meaningful Patterns**: Use precise glob patterns to target the exact files you need (e.g., `**/*.log`, `test-output/screenshots/*.png`).
-   **`allowEmpty: true` for Conditional Artifacts**: For artifacts like failure screenshots or crash logs that might not always exist, set `allowEmpty: true` to prevent the `archiveArtifacts` step from failing the build.
-   **`fingerprint: true` for Traceability**: Use `fingerprint: true` for artifacts that are crucial for traceability, such as released binaries or important test reports, to track their usage across the system.
-   **Post-build Actions**: Place `archiveArtifacts` within the `post` section of your Jenkinsfile (e.g., `always`, `success`, `failure`) to ensure artifacts are collected regardless of the build outcome.
-   **Cleanup Old Artifacts**: Configure Jenkins to discard old builds and their associated artifacts to manage disk space, especially for frequently run jobs. This can be done via "Discard Old Builds" in job configuration.

## Common Pitfalls
-   **Incorrect File Paths/Patterns**: Using incorrect relative paths or glob patterns can lead to artifacts not being found or archiving unintended files. Always verify paths relative to the workspace.
-   **Archiving Too Many Files**: Archiving entire directories without specific patterns can lead to archiving large, unnecessary files, consuming excessive disk space and slowing down builds.
-   **Lack of `allowEmpty`**: If an artifact (like a screenshot on failure) is not always generated, and `allowEmpty` is `false` (default), the `archiveArtifacts` step will fail the build if the pattern yields no matches.
-   **Insufficient Disk Space**: Continuously archiving large artifacts without a proper retention policy can quickly fill up Jenkins server disk space, leading to build failures or performance issues.
-   **Security Implications**: Ensure that sensitive information is not accidentally archived as part of test artifacts. Cleanse logs or exclude directories containing sensitive data.

## Interview Questions & Answers
1.  **Q**: Why is archiving test artifacts important in a CI/CD pipeline?
    **A**: Archiving test artifacts is crucial for several reasons:
    *   **Debugging**: Provides essential diagnostic information (screenshots, logs, videos) to quickly identify the root cause of test failures without re-running tests.
    *   **Traceability & Auditing**: Offers a historical record of test results and application behavior for compliance, audits, and understanding changes over time.
    *   **Collaboration**: Makes test results easily accessible to all team members, fostering better collaboration between developers, QAs, and operations.
    *   **Evidence**: Serves as evidence of successful test execution or specific application states, which can be vital for release decisions.

2.  **Q**: How would you configure Jenkins to archive only screenshots taken during failed Playwright tests?
    **A**: I would use the `archiveArtifacts` step within the `post` section of the Jenkinsfile, specifically in an `always` or `failure` block, to ensure it runs even if tests fail. Playwright can be configured to save screenshots to a specific directory (e.g., `test-results/screenshots`). The `archiveArtifacts` step would then target these files using a pattern like `test-results/screenshots/*.png`. It's important to set `allowEmpty: true` because screenshots are only generated on failure, and the step shouldn't fail if no screenshots are present for a successful build.

    ```groovy
    post {
        always {
            script {
                archiveArtifacts artifacts: 'test-results/screenshots/*.png', allowEmpty: true
            }
        }
    }
    ```

3.  **Q**: Explain the `fingerprint` option in `archiveArtifacts` and when you would use it.
    **A**: The `fingerprint` option, when set to `true`, tells Jenkins to compute a cryptographic hash (fingerprint) of the archived files. This fingerprint is then associated with the build that produced it and any subsequent builds that use or consume that artifact. I would use `fingerprint: true` for artifacts that need to be tracked for their lifecycle, such as:
    *   **Deployable builds/executables**: To know which exact build produced a deployed version.
    *   **Shared libraries or modules**: To track which projects are using which version of a component.
    *   **Compliance/Audit trails**: To prove that a specific version of a report or configuration was used in a particular build.
    It's excellent for understanding dependencies and ensuring traceability across complex build pipelines.

## Hands-on Exercise
**Scenario**: You have a Jenkins pipeline that runs Playwright UI tests. These tests are configured to save screenshots to a directory named `playwright-report/screenshots` on test failure and generate a JUnit XML report in `playwright-report/results.xml`.

**Task**: Modify the provided `Jenkinsfile` snippet to:
1.  Archive all `.png` files from `playwright-report/screenshots`.
2.  Archive the `playwright-report/results.xml` file.
3.  Ensure the pipeline doesn't fail if no screenshots are found (e.g., if all tests pass).
4.  Fingerprint the `results.xml` file for traceability.

```groovy
// Existing Jenkinsfile snippet
pipeline {
    agent any
    stages {
        stage('Test') {
            steps {
                script {
                    sh 'npm install'
                    // Assume Playwright tests run here and generate artifacts
                    sh 'npx playwright test --reporter=junit --output=playwright-report/results.xml || true'
                }
            }
        }
    }
    post {
        always {
            script {
                echo 'TODO: Add artifact archiving here.'
                // Your solution goes here
            }
        }
    }
}
```

**Solution:**

```groovy
pipeline {
    agent any
    stages {
        stage('Test') {
            steps {
                script {
                    sh 'npm install'
                    // Assume Playwright tests run here and generate artifacts
                    sh 'npx playwright test --reporter=junit --output=playwright-report/results.xml || true'
                }
            }
        }
    }
    post {
        always {
            script {
                echo 'Archiving test artifacts...'
                archiveArtifacts artifacts: 'playwright-report/screenshots/*.png', allowEmpty: true
                archiveArtifacts artifacts: 'playwright-report/results.xml', fingerprint: true
            }
        }
    }
}
```

## Additional Resources
-   **Jenkins Pipeline Documentation - `archiveArtifacts`**: [https://www.jenkins.io/doc/pipeline/steps/workflow-basic-steps/#archiveartifacts-archive-the-artifacts](https://www.jenkins.io/doc/pipeline/steps/workflow-basic-steps/#archiveartifacts-archive-the-artifacts)
-   **Jenkins Fingerprinting**: [https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#fingerprints](https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#fingerprints)
-   **Ant-style Patterns**: [https://ant.apache.org/manual/dirtasks.html#patterns](https://ant.apache.org/manual/dirtasks.html#patterns)
